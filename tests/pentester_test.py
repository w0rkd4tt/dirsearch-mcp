#!/usr/bin/env python3
"""
Enhanced Pentester Test for Dirsearch-MCP
Optimized for maximum directory discovery
"""
import asyncio
import sys
from pathlib import Path
from typing import List, Dict, Any
import time
from datetime import datetime

# Add project root to path
sys.path.insert(0, str(Path(__file__).parent))

from src.core.dirsearch_engine import DirsearchEngine, ScanOptions, ScanResult
from src.utils.logger import LoggerSetup


class PentesterScanner:
    """Enhanced scanner for penetration testing"""
    
    def __init__(self):
        LoggerSetup.initialize()
        self.logger = LoggerSetup.get_logger(__name__)
        self.engine = DirsearchEngine(logger=self.logger)
        
        # Tracking results
        self.all_results = []
        self.found_directories = []
        self.found_files = []
        
    async def load_wordlist(self, choice: str) -> List[str]:
        """Load wordlist based on user choice"""
        if choice == "1":
            # Common wordlist
            wordlist_path = Path("wordlists/common.txt")
            if not wordlist_path.exists():
                wordlist_path = Path("wordlists/general/common.txt")
            
            if wordlist_path.exists():
                print(f"Loading common wordlist from: {wordlist_path}")
                with open(wordlist_path, 'r', encoding='utf-8', errors='ignore') as f:
                    wordlist = [line.strip() for line in f if line.strip() and not line.startswith('#')]
                print(f"Loaded {len(wordlist)} paths from common.txt")
                return wordlist
            else:
                print("common.txt not found, using default common paths")
                return self.get_default_common_wordlist()
                
        elif choice == "2":
            # Monster wordlist
            wordlist_path = Path("wordlists/monster-all.txt")
            if not wordlist_path.exists():
                wordlist_path = Path("wordlists/general/monster-all.txt")
                
            if wordlist_path.exists():
                print(f"Loading monster wordlist from: {wordlist_path}")
                with open(wordlist_path, 'r', encoding='utf-8', errors='ignore') as f:
                    wordlist = [line.strip() for line in f if line.strip() and not line.startswith('#')]
                print(f"Loaded {len(wordlist)} paths from monster-all.txt")
                return wordlist
            else:
                print("monster-all.txt not found, using extended wordlist")
                return self.get_extended_wordlist()
                
        elif choice == "3":
            # Custom wordlist
            custom_path = input("Enter path to custom wordlist: ").strip()
            if Path(custom_path).exists():
                print(f"Loading custom wordlist from: {custom_path}")
                with open(custom_path, 'r', encoding='utf-8', errors='ignore') as f:
                    wordlist = [line.strip() for line in f if line.strip() and not line.startswith('#')]
                print(f"Loaded {len(wordlist)} paths from {custom_path}")
                return wordlist
            else:
                print(f"File not found: {custom_path}")
                return []
                
        else:
            # Interactive input
            print("Enter paths (one per line, empty line to finish):")
            wordlist = []
            while True:
                path = input().strip()
                if not path:
                    break
                wordlist.append(path)
            print(f"Loaded {len(wordlist)} custom paths")
            return wordlist
            
    def get_default_common_wordlist(self) -> List[str]:
        """Default common wordlist for pentesting"""
        return [
            # Administrative
            "admin", "administrator", "admin-panel", "control-panel", "cpanel",
            "wp-admin", "admin.php", "administrator.php", "login", "signin",
            
            # API endpoints
            "api", "v1", "v2", "api/v1", "api/v2", "rest", "graphql", "swagger",
            "api-docs", "api/documentation", "api/swagger", "api/users", "api/auth",
            
            # Backup files
            "backup", "backups", "backup.sql", "database.sql", "dump.sql",
            "backup.zip", "site.zip", "www.zip", "archive.zip", "db_backup.sql",
            
            # Configuration
            "config", "configuration", "config.php", "settings", "settings.php",
            ".env", ".env.local", ".env.production", "web.config", "app.config",
            
            # Development
            "dev", "development", "test", "testing", "debug", "staging", "demo",
            "sandbox", "alpha", "beta", "stage", "uat",
            
            # Hidden files
            ".git", ".git/config", ".gitignore", ".svn", ".htaccess", ".htpasswd",
            ".DS_Store", ".idea", ".vscode", "Thumbs.db",
            
            # Common directories
            "assets", "static", "public", "private", "uploads", "upload", "files",
            "documents", "media", "images", "img", "css", "js", "javascript",
            "includes", "inc", "src", "lib", "vendor", "node_modules",
            
            # Database
            "phpmyadmin", "pma", "mysql", "adminer", "adminer.php", "db", "database",
            "sql", "data", "phpMyAdmin", "myadmin", "dbadmin",
            
            # Logs and info
            "logs", "log", "error.log", "access.log", "debug.log", "app.log",
            "phpinfo.php", "info.php", "test.php", "robots.txt", "sitemap.xml",
            
            # CMS specific
            "wp-content", "wp-includes", "wp-login.php", "xmlrpc.php",
            "administrator", "components", "modules", "plugins", "themes",
            "templates", "cache", "tmp", "temp"
        ]
        
    def get_extended_wordlist(self) -> List[str]:
        """Extended wordlist for comprehensive scanning"""
        basic = self.get_default_common_wordlist()
        extended = [
            # More admin variations
            "admin1", "admin2", "admin123", "administrator/index.php",
            "admin/admin.php", "admin_area", "adminarea", "admincp",
            "admincontrol", "adminpanel", "controlpanel", "manager",
            
            # More API paths
            "api/v3", "api/v4", "api/users/login", "api/auth/login",
            "api/token", "api/refresh", "api/register", "api/admin",
            "rest/api", "rest/v1", "rest/v2", "services", "service",
            
            # Version control
            ".git/HEAD", ".git/config", ".git/index", ".gitattributes",
            ".svn/entries", ".svn/all-wcprops", ".hg", ".bzr", "CVS",
            
            # Backup variations
            "backup.tar.gz", "backup.tgz", "backup.rar", "site.tar.gz",
            "www.tar.gz", "public_html.zip", "html.zip", "web.zip",
            "database.zip", "db.zip", "mysql.zip", "backup/", "backups/",
            
            # More config files
            "config.json", "config.xml", "config.yml", "config.yaml",
            "configuration.json", "settings.json", "parameters.yml",
            "database.yml", "secrets.yml", ".env.example", ".env.dev",
            
            # Framework specific
            "application", "app", "system", "core", "bootstrap",
            "framework", "library", "helpers", "models", "views",
            "controllers", "routes", "middleware", "storage",
            
            # Server files
            "server-status", "server-info", ".well-known", "crossdomain.xml",
            "clientaccesspolicy.xml", "WEB-INF", "META-INF", "MANIFEST.MF",
            
            # Archive files
            "archive", "archives", "old", "old-site", "_old", "~",
            "Copy of", "backup-", "-backup", "_backup", ".backup",
            
            # Hidden directories
            "_private", "_hidden", ".hidden", "_files", "_data",
            "_tmp", "_temp", "_cache", "_logs", "_backup",
            
            # Additional paths
            "cgi-bin", "fcgi-bin", "cgi", "servlet", "jsp", "asp",
            "aspx", "cfm", "cfc", "pl", "py", "rb", "do", "action",
            "download", "downloads", "export", "import", "feed", "rss",
            "atom", "print", "pdf", "json", "xml", "ajax", "jsonp",
            "callback", "api-key", "token", "oauth", "auth", "sso",
            
            # DVWA/CTF specific paths based on your structure
            "dvwa", "DBMS", "hackable", "vulnerabilities", "setup",
            "security", "instructions", "about", "phpinfo",
            "vulnerabilities/brute", "vulnerabilities/exec", 
            "vulnerabilities/sqli", "vulnerabilities/sqli_blind",
            "vulnerabilities/upload", "vulnerabilities/xss_d",
            "vulnerabilities/xss_r", "vulnerabilities/xss_s",
            "vulnerabilities/csrf", "vulnerabilities/captcha",
            "vulnerabilities/fi", "vulnerabilities/weak_id",
            "vulnerabilities/open_redirect", "vulnerabilities/csp",
            "vulnerabilities/javascript", "vulnerabilities/authbypass",
            "external", "recaptcha", "flags", "source", "help",
            "includes", "graphics", "docker", "docs", "tests",
            "backup-db", "secret", "heartbeat", "public"
        ]
        
        return basic + extended
        
    async def scan_with_pentester_options(self, target: str, wordlist: List[str]):
        """Perform enhanced scan with pentester optimizations"""
        print(f"\n{'='*60}")
        print(f"PENTESTER ENHANCED SCAN")
        print(f"Target: {target}")
        print(f"Wordlist size: {len(wordlist)} paths")
        print(f"{'='*60}\n")
        
        # Ask for recursive options
        print("\nRecursive Scanning Options:")
        print("1. Shallow scan (depth 1)")
        print("2. Medium scan (depth 2)")
        print("3. Deep scan (depth 3)")
        print("4. Very deep scan (depth 5)")
        print("5. Custom depth")
        
        depth_choice = input("\nSelect recursion depth [1-5]: ").strip()
        
        if depth_choice == "1":
            recursion_depth = 1
        elif depth_choice == "2":
            recursion_depth = 2
        elif depth_choice == "3":
            recursion_depth = 3
        elif depth_choice == "4":
            recursion_depth = 5
        elif depth_choice == "5":
            custom_depth = input("Enter custom depth (1-10): ").strip()
            recursion_depth = int(custom_depth) if custom_depth.isdigit() and 1 <= int(custom_depth) <= 10 else 3
        else:
            recursion_depth = 3  # Default
            
        # Pentester-optimized options
        options = ScanOptions(
            threads=1,                       # Single thread for sequential scanning
            timeout=15,                      # Reasonable timeout
            recursive=True,                  # Always recursive for depth
            recursion_depth=recursion_depth, # User-selected depth
            detect_wildcards=True,           # Essential for accuracy
            follow_redirects=False,          # See actual redirect status
            extensions=[],                   # No extensions initially
            exclude_status_codes=[],         # Don't exclude anything
            include_status_codes=None,       # Include all status codes
            max_retries=2,                   # Retry on failure
            crawl=True,                      # Extract paths from content
            user_agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
        )
        
        print("Scan configuration:")
        print(f"  • Threads: {options.threads} (Sequential mode)")
        print(f"  • Recursive: Yes (depth: {options.recursion_depth})")
        print(f"  • Wildcard detection: Yes")
        print(f"  • Content crawling: Yes")
        print(f"  • Including ALL status codes")
        print("\nStarting sequential scan...\n")
        
        # Set up result callback to track findings
        def on_result(result: ScanResult):
            self.all_results.append(result)
            
            # Categorize results
            if result.is_directory:
                self.found_directories.append(result)
            else:
                self.found_files.append(result)
                
            # Print significant findings immediately
            if result.status_code in [200, 301, 302, 401, 403]:
                status_color = {
                    200: "\033[92m",  # Green
                    301: "\033[93m",  # Yellow
                    302: "\033[93m",  # Yellow
                    401: "\033[91m",  # Red
                    403: "\033[91m"   # Red
                }.get(result.status_code, "\033[0m")
                
                reset = "\033[0m"
                type_indicator = "📁" if result.is_directory else "📄"
                
                print(f"{status_color}[{result.status_code}]{reset} {type_indicator} {result.path} - {result.size} bytes")
                
                # Show when recursive scan will happen on a directory
                if result.is_directory and result.status_code in [200, 301, 302]:
                    print(f"     🔄 Recursive scan queued for: {result.path}")
                
        # Set callbacks
        self.engine.set_result_callback(on_result)
        
        # Start timing
        start_time = time.time()
        
        # Run scan with display progress
        try:
            results = await self.engine.scan_target(target, wordlist, options, display_progress=True)
            
            # Calculate duration
            duration = time.time() - start_time
            
            # Display comprehensive results
            self.display_pentester_report(target, results, duration)
            
        except KeyboardInterrupt:
            print("\n\nScan interrupted by user")
        except Exception as e:
            print(f"\n\nError during scan: {e}")
            import traceback
            traceback.print_exc()
        finally:
            await self.engine.close()
            
    def display_pentester_report(self, target: str, results: List[ScanResult], duration: float):
        """Display comprehensive pentester report"""
        print(f"\n\n{'='*60}")
        print(f"PENETRATION TEST REPORT")
        print(f"{'='*60}")
        print(f"Target: {target}")
        print(f"Scan Duration: {duration:.2f} seconds")
        print(f"Total Paths Checked: {len(self.all_results)}")
        print(f"Directories Found: {len(self.found_directories)}")
        print(f"Files Found: {len(self.found_files)}")
        
        # Group by status code
        status_groups = {}
        for result in results:
            status = result.status_code
            if status not in status_groups:
                status_groups[status] = []
            status_groups[status].append(result)
            
        print(f"\nResults by Status Code:")
        print(f"{'-'*40}")
        for status in sorted(status_groups.keys()):
            count = len(status_groups[status])
            print(f"  [{status}]: {count} results")
            
        # Critical findings (200 OK)
        if 200 in status_groups:
            print(f"\n🎯 ACCESSIBLE RESOURCES (200 OK) - {len(status_groups[200])} found:")
            print(f"{'-'*50}")
            for result in sorted(status_groups[200], key=lambda x: x.path):
                type_ind = "[DIR]" if result.is_directory else "[FILE]"
                print(f"  {type_ind} {result.path} ({result.size} bytes)")
                
        # Redirects (potential directories)
        redirects = []
        if 301 in status_groups:
            redirects.extend(status_groups[301])
        if 302 in status_groups:
            redirects.extend(status_groups[302])
            
        if redirects:
            print(f"\n↪️ REDIRECTS (301/302) - {len(redirects)} found:")
            print(f"{'-'*50}")
            for result in sorted(redirects, key=lambda x: x.path):
                print(f"  [{result.status_code}] {result.path}")
                if result.redirect_url:
                    print(f"       → {result.redirect_url}")
                    
        # Forbidden (exists but no access)
        if 403 in status_groups:
            print(f"\n🔒 FORBIDDEN (403) - {len(status_groups[403])} found:")
            print(f"{'-'*50}")
            for result in sorted(status_groups[403], key=lambda x: x.path):
                print(f"  {result.path}")
                
        # Unauthorized (requires auth)
        if 401 in status_groups:
            print(f"\n🔐 REQUIRES AUTHENTICATION (401) - {len(status_groups[401])} found:")
            print(f"{'-'*50}")
            for result in sorted(status_groups[401], key=lambda x: x.path):
                print(f"  {result.path}")
                
        # Security analysis
        print(f"\n🛡️ SECURITY ANALYSIS:")
        print(f"{'-'*50}")
        
        # Check for sensitive files
        sensitive_patterns = ['.git', '.env', 'config', 'backup', 'admin', 'phpmyadmin', '.sql', '.zip']
        sensitive_found = []
        
        for result in results:
            if result.status_code in [200, 301, 302, 403]:
                for pattern in sensitive_patterns:
                    if pattern in result.path.lower():
                        sensitive_found.append((result, pattern))
                        break
                        
        if sensitive_found:
            print(f"⚠️  SENSITIVE RESOURCES DETECTED:")
            for result, pattern in sensitive_found:
                print(f"  [{result.status_code}] {result.path} (matched: {pattern})")
        else:
            print("✓ No obvious sensitive resources detected")
            
        # Directory Tree Structure
        print(f"\n📂 DIRECTORY TREE STRUCTURE:")
        print(f"{'-'*50}")
        
        # Build directory tree from results
        tree_structure = self.build_directory_tree(results)
        self.print_tree(tree_structure)
        
        # Recommendations
        print(f"\n💡 RECOMMENDATIONS:")
        print(f"{'-'*50}")
        
        if 200 in status_groups:
            print("  1. Review all accessible resources for sensitive information")
        if 403 in status_groups:
            print("  2. Investigate 403 Forbidden resources - they exist but are protected")
        if 401 in status_groups:
            print("  3. Test authentication endpoints for weak credentials")
        if redirects:
            print("  4. Follow redirects to discover additional attack surface")
            
        # Export option
        print(f"\n📁 Export results to file? (y/n): ", end="")
        if input().lower() == 'y':
            self.export_results(target, results, duration)
            
    def export_results(self, target: str, results: List[ScanResult], duration: float):
        """Export results to file"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"pentester_scan_{target.replace('://', '_').replace('/', '_')}_{timestamp}.txt"
        
        with open(filename, 'w') as f:
            f.write(f"PENTESTER SCAN REPORT\n")
            f.write(f"{'='*60}\n")
            f.write(f"Target: {target}\n")
            f.write(f"Scan Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
            f.write(f"Duration: {duration:.2f} seconds\n")
            f.write(f"Total Results: {len(results)}\n\n")
            
            # Sort by status code and path
            sorted_results = sorted(results, key=lambda x: (x.status_code, x.path))
            
            current_status = None
            for result in sorted_results:
                if result.status_code != current_status:
                    current_status = result.status_code
                    f.write(f"\n[{current_status}] Status Code:\n")
                    f.write(f"{'-'*40}\n")
                    
                type_ind = "[DIR]" if result.is_directory else "[FILE]"
                f.write(f"{type_ind} {result.path} ({result.size} bytes)\n")
                if result.redirect_url:
                    f.write(f"     → Redirect: {result.redirect_url}\n")
                    
        print(f"Results exported to: {filename}")
    
    def build_directory_tree(self, results: List[ScanResult]) -> Dict[str, Any]:
        """Build a hierarchical directory tree from scan results"""
        tree = {
            'name': '/',
            'children': {},
            'status': None,
            'is_directory': True
        }
        
        for result in results:
            if result.status_code in [200, 301, 302, 403]:  # Only include accessible/interesting paths
                path = result.path.strip('/')
                if not path:
                    continue
                    
                parts = path.split('/')
                current = tree
                
                # Navigate through the tree
                for i, part in enumerate(parts):
                    if part not in current['children']:
                        current['children'][part] = {
                            'name': part,
                            'children': {},
                            'status': None,
                            'is_directory': True
                        }
                    
                    # Update status for the final part
                    if i == len(parts) - 1:
                        current['children'][part]['status'] = result.status_code
                        current['children'][part]['is_directory'] = result.is_directory
                    
                    current = current['children'][part]
        
        return tree
    
    def print_tree(self, tree: Dict[str, Any], prefix: str = "", is_last: bool = True, depth: int = 0):
        """Print directory tree structure with indentation"""
        if depth == 0:  # Skip root
            for i, (name, child) in enumerate(tree['children'].items()):
                is_last_child = i == len(tree['children']) - 1
                self.print_tree(child, prefix, is_last_child, depth + 1)
            return
        
        # Print current node
        connector = "└── " if is_last else "├── "
        status_text = f" [{tree['status']}]" if tree['status'] else ""
        dir_indicator = "📁" if tree['is_directory'] else "📄"
        
        print(f"{prefix}{connector}{dir_indicator} {tree['name']}{status_text}")
        
        # Update prefix for children
        extension = "    " if is_last else "│   "
        new_prefix = prefix + extension
        
        # Print children
        children_items = list(tree['children'].items())
        for i, (name, child) in enumerate(children_items):
            is_last_child = i == len(children_items) - 1
            self.print_tree(child, new_prefix, is_last_child, depth + 1)


async def main():
    """Main pentester interface"""
    scanner = PentesterScanner()
    
    print("""
╔══════════════════════════════════════════════════════════╗
║           DIRSEARCH-MCP PENTESTER EDITION                ║
║         Maximum Directory Discovery Scanner               ║
╚══════════════════════════════════════════════════════════╝
""")
    
    # Get target
    target = input("Enter target URL: ").strip()
    if not target:
        target = "http://testphp.vulnweb.com"
        print(f"Using default target: {target}")
        
    # Ensure URL has protocol
    if not target.startswith(('http://', 'https://')):
        target = 'http://' + target
        
    # Select wordlist
    print("\nSelect wordlist:")
    print("1. Common wordlist (quick scan)")
    print("2. Monster wordlist (comprehensive)")
    print("3. Custom wordlist (from file)")
    print("4. Manual input")
    
    choice = input("\nYour choice [1-4]: ").strip()
    
    # Load wordlist
    wordlist = await scanner.load_wordlist(choice)
    
    if not wordlist:
        print("No wordlist loaded, exiting...")
        return
        
    # Run scan
    await scanner.scan_with_pentester_options(target, wordlist)


if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\n\nScan terminated by user")
    except Exception as e:
        print(f"\n\nError: {e}")
        import traceback
        traceback.print_exc()